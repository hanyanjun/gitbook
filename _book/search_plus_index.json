{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 个人记录学习 markdown语法查询 "},"content/help/readme.html":{"url":"content/help/readme.html","title":"帮助","keywords":"","body":""},"content/help/configHelp.html":{"url":"content/help/configHelp.html","title":"gitbook配置","keywords":"","body":"{ \"plugins\": [ \"-lunr\", \"-search\", \"search-plus\", \"splitter\", \"copy-code-button\", \"expandable-chapters-small\" ] } search-plus 让搜索支持中文，注意需要先把默认的两个插件lunr和serach禁用掉，禁用的方式就是在前面加上-号 spliter 菜单栏宽度可调节 copy-code-button 代码可以一键 copy expandable-chapters-small 菜单栏可以折叠 gitbook-button配置 ``` { \"plugins\": [ \"github-buttons\" ], \"pluginsConfig\": { \"github-buttons\": {\"buttons\": [{ \"user\": \"azu\", \"repo\": \"JavaScript-Plugin-Architecture\", \"type\": \"star\", \"size\": \"large\" }, { \"user\": \"azu\", \"type\": \"follow\", \"width\": \"230\", \"count\": false }] } } } ``` Option Description 备注 user GitHub username that owns the repo/Username to sponsor 必须，用户名 repo GitHub repository to pull the forks and watchers counts 必须，仓库名 type Type of button to show: watch, fork, sponsor, or follow 必须，4种类型之一 count Show the optional watchers or forks count: none by default or true 可选，是否显示计数 size Optional flag for using a larger button: none by default or large 可选，按钮大小 "},"content/help/plugins.html":{"url":"content/help/plugins.html","title":"gitbook插件","keywords":"","body":"` GitBook 插件 Copy-code-button Simple-page-toc ` GitBook 插件 Copy-code-button 为代码块添加复制的按钮。 插件地址 { \"plugins\": [\"copy-code-button\"] } Simple-page-toc 自动生成本页的目录结构。另外 GitBook 在处理重复的标题时有些问题，所以尽量不适用重复的标题。 插件地址 { \"plugins\" : [ \"simple-page-toc\" ], \"pluginsConfig\": { \"simple-page-toc\": { \"maxDepth\": 3, \"skipFirstH1\": true } } } 使用方法: 在需要生成目录的地方加上 "},"content/work/readme.html":{"url":"content/work/readme.html","title":"面试知识总结","keywords":"","body":"原生 html css svg javascript es6 ts 协议 http | https ws | wss 数据结构 算法 排序 场景 构建工具 webpack gulp rollup ci docker 测试 版本工具 git svn 框架 vue react node axios koa2 router 优化 网络 构建 原生 框架 架构 0->1 打包工具 自动化部署 规范 常见面试题 技术性问题 场景性问题 项目结合问题 "},"content/work/html.html":{"url":"content/work/html.html","title":"html部分","keywords":"","body":"img 标签 title 和 alt 有什么区别 1.title是global attributes之一，用于为元素提供附加的 advisory information。通常当鼠标滑动到元素上的时候显示。 2.alt是 img 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 html标签嵌套规则 内联标签不能包含块标签 p标签不能包含块标签 有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是： h1、h2、h3、h4、h5、h6、p、dt strong em 和 b i 标签有什么区别 b 、 i 是视觉元素；表示 无意义的 加粗和斜体； strong 、em 是表达元素；表示 有意义的 加粗和斜体； em 表示一般强调的文本， strong表示 重要强调的问题； 即 b i为 无意义标签； strong em 为有意义标签； input 类型 text 、 password 、 submit 、 radio 、 checkbox 、button 、 number 、 date 、 color 、 range 、 month 、 week 、time 、 datetime 、datetime-local 、email 、search 、 te 、 url "},"content/work/css.html":{"url":"content/work/css.html","title":"css部分","keywords":"","body":"伪类和伪元素 伪元素 用于创建不在文档中的元素，并未其添加样式；如： ::before 等； 一般为双冒号用来区分伪类和伪元素，但是浏览器对于单冒号的伪元素也是支持的； 伪类 本质为css选择器；主要为：用户行为等自动添加的样式提供可供css选择的样式控制；如：:hover 如何实现 宽高比为4 :3 的div 利用padding ， 当 margin padding left/top 取值百分比，以父级div 的宽度计算； 什么是margin重叠 相邻元素margin 重叠 ， 父子元素margin 重叠； 如果都是正边界，结果的边界宽度是相邻边界宽度中最大的值 如果出现负边界，则在最大的正边界中减去绝对值最大的负边界 如果没有正边界，则从零中减去绝对值最大的负边界 flex flex : inital => 0 1 auto ; auto => 1 1 auto ; none => 0 0 auto; flex : 1 => 1 1 auto; 圣杯布局 双飞翼布局 flex grid floa absolute @import link 区别 加载时机： link 解析到加载， @import 页面加载后加载； 引入类型： link 可加载其他，@import 只适用于css； 权重： link权重大于@import，@import引入的css 会置于顶部，如果样式有重复则@import中样式不会生效； 可通过dom控制： link可以通过js中dom接口动态插入，@import则不可以； positon : absolute 定位原点 不设置left top ， 以祖先元素中position中static中的第一个元素的content位置为起始位置，如果设置left 0 top 0 以padding 为起始位置； 绝对定位元素与非绝对定位元素的百分比计算的区别 绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的paddingbox来计算的。 非绝对定位元素的宽高百分比则是相对于父元素的contentbox来计算的。 元素竖向的百分比设定是相对于容器的高度吗？ 如果是height的话，是相对于包含块的高度。 如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。 渲染过程 dom tree css tree layout paint compositing 参考文章 掘金 腾讯云 "},"content/work/javascript.html":{"url":"content/work/javascript.html","title":"原生js","keywords":"","body":"模块化 amd cmd amd require.js 依赖前置 cmd sea.js 依赖就近 js中 defer async 都是异步执行js 的方式； defer : 立即下载 异步执行；（页面加载后执行）（DomContentLoaded） async : 异步下载 异步执行；（页面加载后执行）（DomContentLoaded） JSON.stringify undefined、任意的函数以及 symbol 作为对象属性值时 JSON.stringify() 对跳过（忽略）它们进行序列化 undefined、任意的函数以及 symbol 作为数组元素值时，JSON.stringify() 将会将它们序列化为 null undefined、任意的函数以及 symbol 被 JSON.stringify() 作为单独的值进行序列化时，都会返回 undefined NaN 和 Infinity 格式的数值及 null 都会被当做 null js == null undefined 相等 一方为boolean ， boolean 转化为数字； 一方为数字 ， 另一方转化为数字； 都为字符串，字符串比较； 一方为对象，另一个不是，调用对象valeOf 方法获取基本类型值后进行对比； 两方都为对象，比较对应内存地址是否相同； 参考文章 参考链接 "},"content/work/http.html":{"url":"content/work/http.html","title":"http","keywords":"","body":"` http介绍 http概念 状态码 http/1.1、http/2、http/3 演变 http缓存 缓存分类： 优先级： http各时期缓存对比： 前端如何设置缓存 本地缓存 网络安全 常见问题 GET 和 POST 方法都是安全和幂等的吗？ 参考文章 ` http介绍 http概念 HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。 状态码 3xx 3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。 http/1.1、http/2、http/3 演变 http/1.0 每次请求需要重新建立连接 http/1.1 长连接，但是会服务端队头阻塞 http/2.0 解决了队头阻塞，但是会发生丢包重传 http/3.0 基于tcp的udp改良的QUIC连接； http缓存 缓存分类： 强制缓存 协商缓存 如果使用了强制缓存，并且未达到过期时间，那么客户端不再和服务端发生交互，此间如果资源发生修改也不会重新获取，有效期内 返回状态码为 200 ， 如果达到过期时间再去服务端拿 服务端返回未过期 返回 304 从缓存中直接拿取；如果使用了协商缓存，每次请求资源都会走服务器进行对比，如果资源未过期 返回状态码 304 ，如果资源已经过期返回最新资源且返回新的资源标识和时间； 优先级： 强缓存优先级大于协商缓存 http各时期缓存对比： http/1.0 通过过期时间：Expires， 服务器时间和客户端时间不一致会出问题； http/1.1 通过cache-control、eTag、last-modified 对比 last-modified 只能到秒级，而且只要文件只要有保存那么时间就会被修改，一个是时间维度不够，一个修改缺乏准确性，所以出现了eTag； 对比： 前端如何设置缓存 一般需要缓存的资源有html页面和其他静态资源： 1、html页面缓存的设置主要是在标签中嵌入标签，这种方式只对页面有效，对页面上的资源无效 1.1、html页面禁用缓存的设置如下： // 仅有IE浏览器才识别的标签，不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求 // 其他主流浏览器识别的标签 // 仅有IE浏览器才识别的标签，该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段 1.2、html设置缓存如下： // 其他主流浏览器识别的标签 // 仅有IE浏览器才识别的标签 2、静态资源的缓存一般是在web服务器上配置的，常用的web服务器有：nginx、apache。具体的配置这里不做详细介绍，大家自行查阅。 本地缓存 网络安全 常见问题 GET 和 POST 方法都是安全和幂等的吗？ 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。 GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。 POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。 参考文章 硬核！30 张图解 HTTP 常见的面试题 深入理解HTTP缓存机制及原理 一文读懂http缓存（超详细） Content Security Policy 入门教程 "}}