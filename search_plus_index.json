{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 个人记录学习 markdown语法查询 "},"content/help/readme.html":{"url":"content/help/readme.html","title":"gitbook使用","keywords":"","body":""},"content/help/plugins.html":{"url":"content/help/plugins.html","title":"gitbook插件","keywords":"","body":"GitBook 插件 记录一些实用的插件, 如果要指定插件的版本可以使用 plugin@0.3.1。下面的插件在 GitBook 的 3.2.3 版本中可以正常工作，因为一些插件可能不会随着 GitBook 版本的升级而升级，即下面的插件可能不适用高版本的 GitBook，所以这里指定了 GitBook 的版本。另外本文记录的插件在 Linux 下都是可以正确工作的，windows 系统没有测试。这里只是列举了一部分插件，如果有其它的需求，可以到 插件官网 区搜索相关插件。 Disqus - Disqus 评论 Search Plus - 支持中文搜索 Prsim - 使用 Prism.js 高亮代码 Advanced Emoji - 支持 emoji 表情 Github - 添加github图标 Github Buttons - 添加项目在 Github 上的 star、fork、watch 信息 Ace Plugin - 支持ace Emphasize - 为文字加上底色 KaTex - 支持数学公式 Include Codeblock - 用代码块显示包含文件的内容 Splitter - 使侧边栏的宽度可以自由调节 Mermaid-gb3 - 支持渲染 Mermaid 图表 Puml - 支持渲染 uml 图 Graph - 使用 function-plot 绘制数学函数图 Chart - 绘制图形 Sharing-plus - 分享当前页面 Tbfed-pagefooter - 为页面添加页脚 Expandable-chapters-small - 使左侧的章节目录可以折叠 Toggle-chapters - 左侧章节目录可以折叠 Sectionx - 将页面分块显示 GA - Google 统计 3-ba - 百度统计 Donate - 打赏插件 Local Video - 使用 Video.js 播放本地视频 Simple-page-toc - 自动生成本页的目录结构 Anchors - 添加 Github 风格的锚点 Anchor-navigation-ex - 添加Toc到侧边悬浮导航以及回到顶部按钮 Edit Link - 链接到当前页源文件上 Sitemap-general - 生成sitemap Favicon - 更改网站的 favicon.ico Todo - 添加 Todo 功能 Terminal - 模拟终端样式 Copy-code-button - 为代码块添加复制按钮 Alerts - 添加不同 alerts 样式的 blockquotes Include-csv - 显示 csv 文件内容 Musicxml - 支持 musicxml 格式的乐谱渲染 Klipse - 集成 Kplise (online code evaluator) Versions-select - 添加版本选择的下拉菜单 Rss - 添加 rss 订阅功能 Theme-comscore - 修改标题和表格颜色 summary - 自动生成目录 prsim 插件地址 主题地址 { \"plugins\": [\"prism\", \"-highlight\"] } \"pluginsConfig\": { \"prism\": { \"css\": [ \"prismjs/themes/prism-solarizedlight.css\" ] } } \"pluginsConfig\": { \"prism\": { \"lang\": { \"flow\": \"typescript\" } } } \"pluginsConfig\": { \"prism\": { \"ignore\": [ \"mermaid\", \"eval-js\" ] } } Copy-code-button 为代码块添加复制的按钮。 插件地址 { \"plugins\": [\"copy-code-button\"] } Simple-page-toc 自动生成本页的目录结构。另外 GitBook 在处理重复的标题时有些问题，所以尽量不适用重复的标题。 插件地址 { \"plugins\" : [ \"simple-page-toc\" ], \"pluginsConfig\": { \"simple-page-toc\": { \"maxDepth\": 3, \"skipFirstH1\": true } } } 使用方法: 在需要生成目录的地方加上 "},"content/work/readme.html":{"url":"content/work/readme.html","title":"面试知识总结","keywords":"","body":"原生 html css svg javascript es6 ts 协议 http | https ws | wss 数据结构 算法 排序 场景 构建工具 webpack gulp rollup ci docker 测试 版本工具 git svn 框架 vue react node axios koa2 router 优化 网络 构建 原生 框架 架构 0->1 打包工具 自动化部署 规范 常见面试题 技术性问题 场景性问题 项目结合问题 "},"content/work/html.html":{"url":"content/work/html.html","title":"html部分","keywords":"","body":"img 标签 title 和 alt 有什么区别 [!NOTE|style:flat]title是global attributes之一，用于为元素提供附加的 advisory information。通常当鼠标滑动到元素上的时候显示。 [!NOTE|style:flat] 2.alt是 img 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 html标签嵌套规则 [!DANGER|style:flat] 内联标签不能包含块标签p标签不能包含块标签有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是： h1、h2、h3、h4、h5、h6、p、dt strong em 和 b i 标签有什么区别 [!NOTE|style:flat]b 、 i 是视觉元素；表示 无意义的 加粗和斜体； [!NOTE|style:flat] strong 、em 是表达元素；表示 有意义的 加粗和斜体； em 表示一般强调的文本， strong表示 重要强调的问题； [!DANGER|style:flat] 即 b i为 无意义标签； strong em 为有意义标签； input 类型 [!TIP|style:flat] text 、 password 、 submit 、 radio 、 checkbox 、button 、 number 、 date 、 color 、 range 、 month 、 week 、time 、 datetime 、datetime-local 、email 、search 、 te 、 url "},"content/work/css.html":{"url":"content/work/css.html","title":"css部分","keywords":"","body":"伪类和伪元素 伪元素 用于创建不在文档中的元素，并未其添加样式；如： ::before 等； 一般为双冒号用来区分伪类和伪元素，但是浏览器对于单冒号的伪元素也是支持的； 伪类 本质为css选择器；主要为：用户行为等自动添加的样式提供可供css选择的样式控制；如：:hover 如何实现 宽高比为4 :3 的div [!TIP|style:flat] 利用padding ， 当 margin padding left/top 取值百分比，以父级div 的宽度计算； 什么是margin重叠 [!TIP|style:flat] 相邻元素margin 重叠 ， 父子元素margin 重叠； [!DANGER|style:flat] 如果都是正边界，结果的边界宽度是相邻边界宽度中最大的值如果出现负边界，则在最大的正边界中减去绝对值最大的负边界如果没有正边界，则从零中减去绝对值最大的负边界 flex flex : inital => 0 1 auto ; auto => 1 1 auto ; none => 0 0 auto;flex : 1 => 1 1 auto; => flex-grow flex-shrink flex-basis; 圣杯布局 双飞翼布局 [!TIP|style:flat] flex grid floa absolute @import link 区别 加载时机： link 解析到加载， @import 页面加载后加载； 引入类型： link 可加载其他，@import 只适用于css； 权重： link权重大于@import，@import引入的css 会置于顶部，如果样式有重复则@import中样式不会生效； 可通过dom控制： link可以通过js中dom接口动态插入，@import则不可以； positon : absolute 定位原点 不设置left top ， 以祖先元素中position中static中的第一个元素的content位置为起始位置，如果设置left 0 top 0 以padding 为起始位置； 绝对定位元素与非绝对定位元素的百分比计算的区别 绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的paddingbox来计算的。 非绝对定位元素的宽高百分比则是相对于父元素的contentbox来计算的。 元素竖向的百分比设定是相对于容器的高度吗？ 如果是height的话，是相对于包含块的高度。 如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。 BFC 概念 格式化上下文, 它是页面中的一块渲染区域,并且有一套渲染规则,它决定了其子元素将如何定位,以及和其他元素的关系和相互渲染作用BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。 触发BFC 根元素() 浮动元素（元素的 float 不是 none）绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） overflow 值不为 visible 的块元素 渲染过程 [!NOTE|style:flat] dom tree css tree layout paint compositing css解析规则为何是从右到左 因为选择器在进行匹配时需要遍历查找，而失败的查找会造成回溯重新遍历，从左到右会有大量失败的回溯，就造成时间的浪费和性能问题； 参考文章 CSS知识点整理 104道CSS面试题 Flex布局教程：语法篇 圣杯布局和双飞翼布局 浅析浏览器渲染原理 "},"content/work/javascript.html":{"url":"content/work/javascript.html","title":"原生js","keywords":"","body":"图灵完备 具备以下特点 顺序执行 条件 循环 模块化：amd、cmd [!NOTE|style:flat] amd require.js 依赖前置 [!NOTE|style:flat] cmd sea.js 依赖就近 js中 defer async [!NOTE|style:flat] 都是异步执行js 的方式；defer : 立即下载 异步执行；（页面加载后执行）（DomContentLoaded）async : 异步下载 异步执行；（页面加载后执行）（DomContentLoaded） JSON.stringify [!NOTE|style:flat] undefined、任意的函数以及 symbol 作为对象属性值时 JSON.stringify() 对跳过（忽略）它们进行序列化 undefined、任意的函数以及 symbol 作为数组元素值时，JSON.stringify() 将会将它们序列化为 null undefined、任意的函数以及 symbol 被 JSON.stringify() 作为单独的值进行序列化时，都会返回 undefined NaN 和 Infinity 格式的数值及 null 都会被当做 null js==判断逻辑 [!NOTE|style:flat] null undefined 相等 一方为boolean ， boolean 转化为数字； 一方为数字 ， 另一方转化为数字； 都为字符串，字符串比较； 一方为对象，另一个不是，调用对象valeOf 方法获取基本类型值后进行对比； 两方都为对象，比较对应内存地址是否相同； 深拷贝 递归 [!DANGER|style:flat] 会产生栈溢出 保存遍历的对象，遍历时若对象被保存，则直接返回 JSON.parse、JSON.stringify [!DANGER|style:flat] 会对部分对象属性过滤 采用循环 var a = { a1: 1, a2: { b1: 1, b2: { c1: 1 } } } function cloneLoop(x) { const root = {}; // 栈 const loopList = [ { parent: root, key: undefined, data: x, } ]; while(loopList.length) { // 深度优先 const node = loopList.pop(); const parent = node.parent; const key = node.key; const data = node.data; // 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素 let res = parent; if (typeof key !== 'undefined') { res = parent[key] = {}; } for(let k in data) { if (data.hasOwnProperty(k)) { if (typeof data[k] === 'object') { // 下一次循环 loopList.push({ parent: res, key: k, data: data[k], }); } else { res[k] = data[k]; } } } } return root; } 采用循环&缓存对象 // 保持引用关系 function cloneForce(x) { // ============= const uniqueList = []; // 用来去重 // ============= let root = {}; // 循环数组 const loopList = [ { parent: root, key: undefined, data: x, } ]; while(loopList.length) { // 深度优先 const node = loopList.pop(); const parent = node.parent; const key = node.key; const data = node.data; // 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素 let res = parent; if (typeof key !== 'undefined') { res = parent[key] = {}; } // ============= // 数据已经存在 let uniqueData = find(uniqueList, data); if (uniqueData) { parent[key] = uniqueData.target; break; // 中断本次循环 } // 数据不存在 // 保存源数据，在拷贝数据中对应的引用 uniqueList.push({ source: data, target: res, }); // ============= for(let k in data) { if (data.hasOwnProperty(k)) { if (typeof data[k] === 'object') { // 下一次循环 loopList.push({ parent: res, key: k, data: data[k], }); } else { res[k] = data[k]; } } } } return root; } function find(arr, item) { for(let i = 0; i 内存泄漏 栈溢出 内存泄漏 垃圾回收机制无法回收变量，导致内存逐渐积累到达瓶颈即为内存溢出或者内存泄漏 [!NOTE|style:flat] 常见内存泄漏 全局变量过多 闭包 dom添加属性或者方法不及时解除引用 栈溢出 入栈太多，出栈太慢，栈内存被占满 [!NOTE|style:flat] 常见栈溢出 递归导致变量无法释放，下次的递归依赖上次的栈中变量 function isEven (num) { if (num === 0) { return true; } if (num === 1) { return false; } return isEven(Math.abs(num) - 2);返回值调用isEven()导致上次的isEvent中的变量，返回值等无法释放，最后导致堆栈溢出 } 参考文章 你不知道的 JSON.stringify() 的威力 深拷贝的终极探索（99%的人都不知道） JavaScript之内存溢出和内存泄漏 "},"content/work/http.html":{"url":"content/work/http.html","title":"http","keywords":"","body":"http介绍 http概念 HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。 url到页面过程 [!NOTE|style:flat] 为什么一开始就进行redirect？浏览器可能已经记住当前地址被永久重定向，所以浏览器一开始需要判断是否需要redirect以及redirect到哪里。APP cache可能当前请求的资源已经被缓存过了。 TCP 三次握手 [!NOTE|style:flat] 为什么需要三次握手？ tcp连接是个消耗性能过程，同时受网络状况的限制，假如发送req时服务端开启端口同时给与响应，但是受网络因素影响，包丢失或者延迟，客户端接收失败超时就会导致客户端会重新发送一个请求，而此时服务端并不知道客户端是否接受成功，那么就不知道开启服务还是关闭服务，端口一直开启中，开销浪费。为了规避建立连接过程中，因为网络因素导致的服务器开销浪费问题。 TCP 四次挥手 URI URL URN URI 统一资源标识符，用来唯一标识互联网上的信息资源，包括URL、URN。 URL 统一资源定位器。 URN 永久统一资源定位符 http状态码 [!NOTE|style:flat] 3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。「301 Moved Permanently」（status code : 302 Found (from disk cache)）表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。「302 Found」 （status code : 302 Found (from disk cache)）表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。 http.createServer(function (request, response) { console.log('request come', request.url) if (request.url === '/') { /** * code 为 200时，不会重定向到/new 只有 302 301 状态码才会。 * code 为 302时，每次访问/都会经过服务端 然后进行重定向。 * code 为 301时，浏览器在访问/时不需要经过服务器而是直接定向到301，慎重使用， * 因为使用301后，浏览器会将 / -> /new 缓存到浏览器端，哪怕服务端更改了其他code， * 浏览器也无法感知，除非用户的浏览器重新清掉缓存。 * */ response.writeHead(302, { // or 301 'Location': '/new' }) response.end() } if (request.url === '/new') { response.writeHead(200, { 'Content-Type': 'text/html', }) response.end('this is content') } }).listen(8888) http发展 http/1.0 每次请求需要重新建立连接 http/1.1 长连接，但是会服务端队头阻塞 http/2.0 解决了队头阻塞，但是会发生丢包重传（信道复用，分帧传输，serve push） http/3.0 基于tcp的udp改良的QUIC连接； 资源获取流程 http缓存 缓存分类 强制缓存 协商缓存 [!DANGER|style:flat] 如果使用了强制缓存，并且未达到过期时间，那么客户端不再和服务端发生交互，此时是浏览器自身的缓存，此间如果资源发生修改也不会重新获取，有效期内 返回状态码为 200 （from memory）， 如果达到过期时间再去服务端拿 服务端返回未过期 返回 304 从缓存中直接拿取；如果使用了协商缓存，每次请求资源都会走服务器进行对比，如果资源未过期 返回状态码 304 ，如果资源已经过期返回最新资源且返回新的资源标识和时间； if (request.url === '/script.js') { const etag = request.headers['if-none-match'] //获取last-modified 对应的header /** * 服务端进行etag验证，如果etag为：777 那么返回状态码为：304，此时从浏览器中读取缓存数据 * * */ if (etag === '777') { response.writeHead(304, { 'Content-Type': 'text/javascript', /*** * max-age=5 , s-maxage=20 在5秒内走的是浏览器缓存，在5-20秒内走的时候代理服务器缓存（如：其他用户访问相同链接 * 获取资源也很快，因为存在代理服务器缓存）； * max-age=5 , s-maxage=20 , private 在5秒内走的是浏览器缓存，在大于5秒不走缓存 * （private 只有浏览器才可以缓存，代理服务器不允许缓存）； * max-age=5 , s-maxage=20 , no-store 都不走缓存 （no-store 浏览器，代理服务器都不缓存） * */ 'Cache-Control': 'max-age=2000000, no-cache', 'Last-Modified': '123', 'Etag': '777' }) /** * 返回304时，此时end中的任何内容都不会返回，因为返回304状态码，那么就会从浏览器中读取缓存的上次的response.end内容 * */ response.end() } else { response.writeHead(200, { 'Content-Type': 'text/javascript', /** * max-age 代表 2000000秒 内进行缓存，（如果是：'Cache-Control': 'max-age=2000000', 代表强制缓存；浏览器自身的缓存，如果* * max-age时间内服务端资源发生修改也不会重新获取。（200 from memory）刷新浏览器缓存解决方式：通过webpack对文件增加hash） * no-cache 代表虽然进行缓存，但是都需要走服务端进行验证， * */ 'Cache-Control': 'max-age=2000000, no-cache', 'Last-Modified': '123', 'Etag': '777' }) response.end('console.log(\"script loaded twice\")') } } }).listen(8888) 缓存优先级 强缓存优先级大于协商缓存 缓存对比 [!NOTE|style:flat] http/1.0 通过过期时间：Expires， 服务器时间和客户端时间不一致会出问题； [!NOTE|style:flat] http/1.1 通过cache-control、eTag、last-modified 对比 last-modified 只能到秒级，而且只要文件只要有保存那么时间就会被修改，一个是时间维度不够，一个修改缺乏准确性，所以出现了eTag； 对比： 前端如何设置缓存 一般需要缓存的资源有html页面和其他静态资源： 1、html页面缓存的设置主要是在标签中嵌入标签，这种方式只对页面有效，对页面上的资源无效 1.1、html页面禁用缓存的设置如下： // 仅有IE浏览器才识别的标签，不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求 // 其他主流浏览器识别的标签 // 仅有IE浏览器才识别的标签，该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段 1.2、html设置缓存如下： // 其他主流浏览器识别的标签 // 仅有IE浏览器才识别的标签 2、静态资源的缓存一般是在web服务器上配置的，常用的web服务器有：nginx、apache。具体的配置这里不做详细介绍，大家自行查阅。 本地缓存 Cookie max-age和expires设置过期时间；Secure只再https的时候发送；HttpOnly无法通过document.cookie访问； 网络安全 1XSS CSRF SQL注入攻击 CORS 该策略是浏览器的策略，不存在于服务端之间请求或者终端命令http请求当中，当一个请求从客户端发出的时候，如果命中CORS策略并且后端未设置 Access-Control-Allow-Origin 时浏览器会将服务端的返回给屏蔽掉，同时在控制台输出CORS的error，该行为是浏览器同源策略行为。 const http = require('http') http.createServer(function (request, response) { console.log('request come', request.url) response.writeHead(200, { 'Access-Control-Allow-Origin': 'http://127.0.0.1:8888', /** * 允许请求携带的headers的key，此时预请求可以通过。 * */ 'Access-Control-Allow-Headers': 'X-Test-Cors', /** * 允许的预请求的method，此时预请求可以通过。 * */ 'Access-Control-Allow-Methods': 'POST, PUT, DELETE', /** * 该请求方式下此时间范围（1000秒）不需要进行验证，即在该时间范围内所有符合条件的预请求都放过不需要进行验证，对应http在该时间范围内都没有* options的预请求。 * */ 'Access-Control-Max-Age': '1000' }) response.end('123') }).listen(8887) 常见问题汇总 1GET和POST方法都是安全和幂等的吗 [!NOTE|style:flat] 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。 GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。 POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。 工具类 hotsadmin 可以将本地服务如：127.0.0.7 映射为 ： xxx.xxx.com，同时chrome可以支持该域名访问服务。 参考文章 硬核！30 张图解 HTTP 常见的面试题 深入理解HTTP缓存机制及原理 一文读懂http缓存（超详细） Content Security Policy 入门教程 常见 Web 安全攻防 "},"content/work/测试.html":{"url":"content/work/测试.html","title":"测试","keywords":"","body":"分类 TDD关注所有功能是否被正确实现，每一个功能都具备对应的测试用例；一般为先写好测试用例，然后再开发代码，这样就可以让测试用例覆盖所有代码。 BDD关注整体行为是否符合预期，适合自顶向下的设计方式。一般是先开发代码，再写单元测试。这个较为常用。 测试步骤 准备阶段 执行阶段 断言阶段 清理阶段 mock 与 spy spy 用于监听一个现有对象上的方法 const bot = { sayHello: name => { console.log(`Hello ${name}!`); } }; describe(\"bot\", () => { it(\"should say hello\", () => { const spy = jest.spyOn(bot, \"sayHello\"); bot.sayHello(\"Michael\"); expect(spy).toHaveBeenCalledWith(\"Michael\"); spy.mockRestore(); }); }); mock function forEach(items, callback) { for (let index = 0; index { it(\"should call callback with each item\", () => { const mockFn = jest.fn(); forEach([1, 2], mockFn); expect(mockFn.mock.calls.length).toBe(2); expect(mockFn.mock.calls[0][0]).toBe(1); expect(mockFn.mock.calls[1][0]).toBe(2); }); }); 参考文章 mock知乎文档 "},"content/work/算法.html":{"url":"content/work/算法.html","title":"算法","keywords":"","body":"LRU算法 LRU（Least recently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下： 新数据插入到链表头部； 每当缓存命中（即缓存数据被访问），则将数据移到链表头部； 当链表满的时候，将链表尾部的数据丢弃。 [!DANGER|style:flat] 当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。复杂度比较简单，代价则是命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。 参考文章 浅析Vue中keep-alive实现原理以及LRU缓存算法 "},"content/work/vue.html":{"url":"content/work/vue.html","title":"vue使用","keywords":"","body":"vue使用知识点 vue父子组件的生命周期调用顺序 [!NOTE|style:flat] 加载渲染过程 父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted 子组件更新过程 父beforeUpdate->子beforeUpdate->子updated->父updated 父组件更新过程 父beforeUpdate->父updated 销毁过程 父beforeDestroy->子beforeDestroy->子destroyed->父destroyed vue 生命周期对应事情 beforeCreated 初始化 events、lifecycle 等 created init props、data、watcher、methods、computed 数据监听，dep添加 beforeMounted complie 生成 render 函数 mounted 调用render生成vNode, 数据订阅,path生成dom 参考 vue组件更新之后获取最新DOM [!NOTE|style:flat] 通过this.$nexttick获取 动态组件 import a from xxx export default { components : { comName : a }, data(){ baseCom : \"comName\" } } 异步组件 export default { components : { Com : ()=> import(xxx) }, data(){ showCom : false }, methods : { changeCom(){ this.data.showCom = true } } } vue如何缓存组件 如果无keep-alive 每次切换状态会触发组件的destoryed和mounted方法，而加上后组件被缓存，mounted只会触发一次，destoryed不会触发v-show 通过css 属性来进行组件缓存，keep-alive通过组件类缓存 import A from \"xxx\" import B from \"xxx\" import C from \"xxx\" export default { components : { A,B,C }, data(){ status : '' }, methods : { changeStatus(status){ this.data.status = status } } } mixin mixin.js export default { data(){ return { city : '北京' } }, mounted(){ console.log('mixin mounted') }, methods: { showName(){ console.log(this.name) } } } index.vue {{city}} {{name}} import Mixin from \"xxx\" export default { mixins : [Mixin] data(){ name : 'index' }, methods : { } } 优势 [!NOTE|style:flat] 逻辑复用 劣势 [!DANGER|style:flat] 变量来源不明确，不利于阅读 多个mixin可能命名重复 复杂度高，可能出现一对多，多对一，多对多关系 compute、watch区别 computed：计算属性 计算属性是由data中的已知值，得到的一个新值。 这个新值只会根据已知值的变化而变化，其他不相关的数据的变化不会影响该新值。 计算属性不在data中，计算属性新值的相关已知值在data中。 别人变化影响我自己。 watch：监听数据的变化 监听data中数据的变化 监听的数据就是data中的已知值 我的变化影响别人 1.watch擅长处理的场景：一个数据影响多个数据 2.computed擅长处理的场景：一个数据受多个数据影响 v-for 和 v-if 优先级 {{ user.name }} 经过计算后： this.users.map(function (user) { if (user.isActive) { return user.name } }) [!TIP|style:flat] v-for 优先级大于 v-if,应该通过计算属性获取符合条件的list，效率更高 vue-router 路由模式 hash 特点 hash 变化不会触发网页跳转，即浏览器的前进、后退 hash 变化不会刷新页面，SPA必须的特点 hash 永远不刽提交到serve端（前端控制，自生自灭） /** * hash变化包括 * 1. js 修改url * 2. 手动修改 url 的 hash * 3. 浏览器前进后退 * */ window.onhashchange = (event) => { console.log('old url' , event.oldURL) console.log('new url' , event.newURL) console.log('hash:',location.hash) } // 页面初次加载获取hash document.addEventListener('DOMContentLoaded',()=>{ console.log('hash:',location.hash) }) history 核心api history.pushState window.onpopstate // 监听浏览器前进后退 window.onpopstate = (event) => { console.log('onpopstate' , event.state,location.pathname) } // 页面初次加载获取hash document.addEventListener('DOMContentLoaded',()=>{ console.log('hash:',location.pathname) }) document.getElementById('btn').addEventListenter('click',()=>{ const state = {name : 'page1'} history.pushState(state, '' , 'page1'); }) 路由配置 动态路由 routes : [ {path : 'user/:id' , component : User} ] 路由懒加载 routes : [ {path : 'user/:id' , component : ()=> import(\"../../user.vue\")} ] "},"content/work/vue原理.html":{"url":"content/work/vue原理.html","title":"vue原理","keywords":"","body":"组件化和MVVM vue 生命周期 大致划分 挂载阶段、更新阶段、销毁阶段 响应式原理 [!DANGER|style:flat] 由于数据劫持会递归调用data数据，如果存在循环引用会造成栈溢出，为此vue 对劫持过的数据 会标记 _ob 属性 keep-alive 原理 [!DANGER|style:flat] abstract: true ,保证keep-alive 的虚拟dom不会被渲染成真实dom keepAlive : true, 保证 keep-alive 包裹子组件的 mounted等生命周期会被跳过 LRU 算法就是 单向链表结构 ， 最近活跃的会被作为链表头部，达到上限 删除链尾 vnode 和 diff 算法 模板编译 组件渲染过程 前端路由 对路由状态对象进行定义后，然后进行数据劫持，当路由状态发生变更触发render更新components，再进行跳转时：会存储上个路由对象的beforeEach，beforeleave、和下个路由对象的beforeEnter、afterEnter进入任务队列中，依次执行，执行完毕进入跳转 [!TIP|style:flat] 核心是：发布订阅模式的router状态的监听；任务队列模式对router守卫功能的触发 hash 模式(hashChange) history 模式(popState) 参考链接 彻底揭秘keep-alive原理 前端路由简介以及vue-router实现原理 "},"content/work/react.html":{"url":"content/work/react.html","title":"react使用","keywords":"","body":"React Class 组件 super函数 绑定this方法 this.a = this.a.bind(this) xxx onClick={this.a.bind(this)} const a = ()=> {} 父子通讯 setState 不可变值 修改state 必须通过 this.setState 去做 如下是错误的： this.state.count++; this.setState({ count : this.state.count }) 同步 or 异步 可能是异步更新 异步场景 this.setState({ state : this.state.count + 1 }, ()=>{ console.log(this.state.count) //拿到最新值 }) console.log(this.state.count) //异步 同步场景 settimeout 中 setTimeout(()=>{ this.setState({ state : this.state.count + 1 }) console.log(this.state.count) //可以获取到最新值 },0) 自己定义的事件函数中 setTimeout(()=>{ this.setState({ state : this.state.count + 1 }) console.log(this.state.count) //可以获取到最新值 },0) document.body.addEventListener('click',()=>{ this.setState({ state : this.state.count + 1 }) console.log(this.state.count) //可以获取到最新值 }) 可能会被合并 this.setState({ state : this.state.count + 1 }) this.setState({ state : this.state.count + 1 }) this.setState({ state : this.state.count + 1 }) [!NOTE] 会合并只会加1次，因为相加之前拿到的都是同一次值，类似于 Object.assign({count : 1},{count: 1},{count : 1}) this.setState((preState)=>{ return {count : preState.count + 1} }) this.setState((preState)=>{ return {count : preState.count + 1} }) this.setState((preState)=>{ return {count : preState.count + 1} }) [!NOTE] 不会被合并，会相加三次 React事件和DOM事件 获取原生对象的方法 event.nativeEvent event.nativeEvent.target 是触发事件元素event.nativeEvent.current.target 是绑定事件的元素 [!DANGER|style:flat] event 是 React 封装的 。 proto.constructor 是 SyntheticEvent SyntheticEvent 模拟出来 DOM 事件所有能力 event事件都会挂在到 document 上 为何要合成事件机制？ 更好的兼容性和跨平台 挂载到 document ， 减少内存消耗， 避免频繁解绑 方便事件的统一管理（如事务机制） 组件生命周期 React 高级特性 函数组件 非受控组件 Portals context 异步组件 性能优化 高阶组件 HOC Render Props 函数组件与类组件对比 纯函数，输入props，输出jsx 没有实例，没有生命周期，无state 不能扩展其它方法 更适用于纯ui组件 非受控组件 ref defaultValue defaultChecked 手动操作 DOM 元素 (input file , 文件上传 ； 富文本编辑器) 对比：受控、非是后空 优先使用受控组件，符合React设计原则 必须操作 DOM 时，使用非受控组件 Portals 组件默认会按照既定层次嵌套渲染，如何让组件渲染到父组件外？ render (){ return ReactDom.createPortal( 组件会再body下 , document.body ) } context 使用场景 设置公共信息（语言，主题） 异步组件 React.lazy React.Suspense const Demo = React.lazy(()=> import('./xxx/xxx.js')) render(){ return( .... loading}> ) } 性能优化 shouldComponentUpdate(简称SCU) PureComponent 和 React.Memo 不可变值 immuSCU [!NOTE] 为什么需要SCU 而不是 React 框架自己把 SCU 给做了？ 1、一般情况下都不需要进行优化，把优化的控制权交给开发者 2、props、state值的结构无法控制可能很复杂，如果使用：_.isEqual 是进行深度比较，那么比较耗费性能 3、React 有默认数据不可变的开发规则，即修改state通过setState方式，但假如开发而未遵循此规则，而框架本身有在SCU中做了_.isEqual 的判断，那么就会导致页面不会更新，如下示例： // 父组件 this.state.list.push({ id : 1, title : 'add' }) this.setState({ list : this.state.list }) // 子组件 假如框架做了此优化 那么子组件将不会更新 shouldComponentUpdate(nextProps,nextState){ if(_.isEqual(nextProps.list , this.props.list)){ return false //不更新 } return true //更新 } [!DANGER] SCU 默认返回 true PureComponent [!NOTE] PureComponent,SCU 中实现了浅比较 class t extends React.PureComponent memo export.default React.memo(T,areEqual) immutable.js 保证React设计数据不可变值的思想，如果想要实现，传统的方式就是使用深拷贝，但是深拷贝太耗性能immutable.js 基于共享数据，速度好 高阶组件 应用场景 生命周期劫持（日志，打点，性能分析） 公共逻辑抽取 条件渲染 实现方式 属性代理 反向继承 Render Props Redux 基本api dispatch（action） reducer -> newState subscribe 触发通知 结合react使用 react-redux connect mapStateToProps mapDispatchToProps 异步action redux-thunk redux-promise redux-saga import {createStore , applyMiddleware} from \"redux\" import thunk from \"redux-thunk\" import rooteReducer from \"./reducers/index\" const store = crateStore(rootReducer , applyMiddleware(thunk)); redux 中间件 函数式编程 纯函数 不可变值 参考文章 React高阶组件(HOC)的入门及实践 详解React生命周期(包括react16最新版) 生命周期图 "},"content/work/react原理.html":{"url":"content/work/react原理.html","title":"react原理","keywords":"","body":"setState 和 batchUpdate 哪些能命中 batchUpdate 机制 生命周期（和它调用的函数） React 中注册的事件（和它调用的函数） React 可以 '管理' 的入口 哪些不能命中 batchUpdate 机制 setTimeout setInterval 等 （和它调用的函数） 自定义的DOM事件（和它调用的函数） React \"管不到\" 的入口 batchUpdate 过程大概 React transaction 事务机制 主要是为 batchUpdate服务 transaction 大致过程 该方式存在哪些问题? 如何解决？（通过fiber） React Fiber "},"content/cli/readme.html":{"url":"content/cli/readme.html","title":"前端架构","keywords":"","body":"常见命令 npm ls -g --depth 0 //查询全局包列表 npm rm -g [包名] //全局删除包名 "},"content/cli/fast.html":{"url":"content/cli/fast.html","title":"快速入门-简易脚手架","keywords":"","body":"开发流程 创建 npm 项目 创建脚手架入口文件，最上方添加 #!/usr/bin/env node 配置 package.json ， 添加bin 属性 \"bin\": { \"fef\": \"bin/index.js\" }, 编写脚手架代码 #!/usr/bin/env node // 注册一个命令 fef init const argv = require('process').argv; const fn = require('../command') /** * [ * 'C:\\\\Program Files\\\\nodejs\\\\node.exe', * 'C:\\\\Users\\\\APUS\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\fef\\\\bin\\\\index.js', * 'init' * ] * */ let command = argv[2]; const options = argv.slice(3) const [option , param] = options; console.log(option , param , argv); if(fn[command]){ // fn[command] && fn[command]() }else{ console.log('请输入正确的命令'); } // 实现参数解析 --version 和 init --name 将脚手架发布到npm 使用流程 安装脚手架 npm install -g [脚手架名] 使用脚手架 脚手架本地link标准流程 链接本地脚手架 cd [脚手架目录] npm link 链接本地库文件 cd [库文件目录] npm link cd [脚手架目录] npm link [库名] 取消链接本地库文件 cd [脚手架目录] npm unlink [库名] cd [库文件目录] npm unlink [!TIP|style:flat] 如果无法使用unlink 请使用： npm rm -g [包名] 强制解除全局软链 [!TIP|style:flat] npm link [包名] ： 将当前项目中 node_modules 下指定的库文件链接到 node 全局 node_modules 下的库文件；可使用 npm ls -g --depth 0 查看全局包列表； "},"content/cli/lerna.html":{"url":"content/cli/lerna.html","title":"lerna","keywords":"","body":"Lerna简介 lerna 是一个优化基于git+npm的多package项目的管理工具 优势 大幅减少重复操作 提升操作的标准化 lerna开发脚手架流程 脚手架项目初始化 初始化npm项目 -> 安装lerna -> lerna init 初始化项目 创建package lerna create 创建 Package -> lerna add 安装依赖 -> lerna link 链接依赖 脚手架开发和测试 lerna exec 执行 shell 脚本 -> lerna run 执行 npm 命令 -> lerna clean 清空依赖 -> lerna bootstrap 重装依赖 脚手架发布上线 lerna version , bump version -> lerna changed 查看上版本依赖的所有变更 -> lerna diff 查看 diff -> lerna publish 项目发布 "},"content/suanfa/readme.html":{"url":"content/suanfa/readme.html","title":"数据结构和算法","keywords":"","body":""},"content/suanfa/intro.html":{"url":"content/suanfa/intro.html","title":"数据结构之基本介绍","keywords":"","body":"基本概念 数据结构 计算机存储、组织数据的方式； 算法 一系列解决问题的清晰指令；程序 = 数据结构 + 算法 ； 数据结构为算法提供服务，算法围绕数据结构操作； 常见数据结构 有顺序 栈、队列、链表 无序 集合、字典 层级 树、堆、图 时间复杂度计算 概念 一个函数，用大o表示，比如：O(1)、O(n)、O(logN)... ； 定性描述该算法的运行时间 时间复杂度图 时间复杂度代码示例 O(1) let i = 0 ; i+= 1; O(n) for(let i = 0; i){ console.log(i) } O(1) + O(n) = O(n) let i = 0 ; i+= 1; for(let j = 0; j){ console.log(j) } O(n)*O(n) = O(n^2) for(let i = 0; i){ for(let j = 0; j){ console.log(j) } } O(logN) let i = 1; while (i 空间复杂度 概念 一个函数，用大O表示，比如：O(1)、O(n)、O(logN)... ；算法在运行过程中临时占用存储空间大小的量度 空间复杂度代码示例 O(1) let i = 0 ; //单个变量 i+= 1; O(n) let list = [] for(let i = 0; i){ list.push(i) } O(n^2) const matrix = []; for(let i = 0; i){ matrix.push([]) for(let j = 0; j){ matrix.push([i]).push(j) } } "},"content/suanfa/zhan.html":{"url":"content/suanfa/zhan.html","title":"数据结构之栈","keywords":"","body":"栈 概念 一个后进先出的数据结构；javascript 中没有栈，但可以用 Array 实现栈的所有功能； 使用场景 十进制转二进制 判断字符串括号是否有效 函数调用堆栈 十进制转二进制 判断字符串号是否有效 函数调用堆栈 "},"content/suanfa/duilie.html":{"url":"content/suanfa/duilie.html","title":"数据结构之队列","keywords":"","body":"队列 概念 一种先进先出的数据结构；javascript 中没有队列，但可以用 Array 实现队列的所有功能； 使用场景 食堂排队打饭 JS异步中的任务队列 计算最近请求次数 食堂排队打饭 JS异步中的任务队列 "},"content/suanfa/lianbiao.html":{"url":"content/suanfa/lianbiao.html","title":"数据结构之链表","keywords":"","body":"链表 概念 多个元素组成的列表；元素存储不连续，用next指针连在一起； 数组 vs 链表 数组：增删非首尾元素时往往需要移动元素。链表：增删非首尾元素，不需要移动元素，只需要更改 next 的指向即可。 JS 的链表 javaScript 中无链表。可以用 Object 模拟链表。 前端与链表 JS中的原型链 原型链的本质就是链表；原型链上的节点是各种原型对象，比如：Function.prototype、Object.prototype ...原型链通过 proto 属性连接各种原型对象； 如果A沿着原型链能够找到 B.prototype , 那么 A instanceof B为 true； 如果在A对象没有找到X属性，那么就会沿着原型链上找X属性； 使用链表指针获取JSON的节点值 const json = { a : {b : { c :1}} }; const path = ['a','b','c']; let p = json; path.forEach(key => { p = p[key] }); 相关面试 instanceof的原理，并用代码实现 const instanceof = (a , b) => { let p = a; while(p){ if(p === b.prototype){ return true; } p = p.__proto__; } return false } let arr = [] instanceof(arr,Object) 实例题 删除节点 解题思路 1.无法操作被删除节点的上个节点直接指向被操作节点的下个节点，所以只能是基于被删除节点和下个节点进行操作；2.将被删除节点的下个节点的值替换当前被删除节点的值；3.将被删除节点的下个节点的next 替换被删除节点的 next； 题目 力扣 933 反转链表 解题思路 1.先去思考如何反转两个节点：将n+1 的 next 指向 n；2.反转多个节点：双指针遍历链表，重复上面操作； 解题步骤 1.双指针一前一后遍历链表； 2.反转双指针； 题目 力扣 206 两数相加 题目 力扣 2 删除排序链表中的重复元素 题目 力扣 83 环形链表 题目 力扣 141 "},"content/suanfa/jihe.html":{"url":"content/suanfa/jihe.html","title":"数据结构之集合","keywords":"","body":"集合 概念 一种 无序且唯一 的数据结构；ES6 中 Set 为集合结构；集合常用操作：去重、判断某元素是否在集合中、求交集... ... ； // 去重 const arr = [1,2,12,1]; const arr2 = [...new Set(arr)]; // 判断元素是否在结合中 const set = new Set(arr); set.has(3) // 求交集 const set2 = new Set([2,3]) const set3 = new Set([...set2].filter(item => set2.has(item))) 前端与集合 Set结构 常用方法 let set = new Set(); set.add(1); set.add(5); set.add(5); set.add('some text'); set.has(5) set.delete(5) for(let item of set) for(let item of set.keys()) for(let item of set.values()) for(let [key,value] of set.entries()) const arr = [...set] const arr1 = Array.from(set) new Set([1,2,3,4]) 实例题 两个数组的交集 题目 力扣 349 "},"content/suanfa/zidian.html":{"url":"content/suanfa/zidian.html","title":"数据结构之字典","keywords":"","body":"字典 集合 以 键值对 的形式存储 唯一值 的数据结构；ES6 中字典，Map； 实例题 两个数组的交集 题目 力扣 349 有效的括号 题目 力扣 20 两数之和 题目 力扣 1 无重复字符的最长字符串 题目 力扣 3 最小覆盖子串 题目 力扣 76 "},"content/suanfa/shu.html":{"url":"content/suanfa/shu.html","title":"数据结构之树","keywords":"","body":"集合 概念 一种 分层 数据的抽象模型；如：DOM树、级联选择、树形控件... ...树常用操作：深度/广度优先遍历、先中后序遍历 深度/广度优先遍历 深度优先 尽可能深的搜索树的分支；类似于书一页一页翻看； 1.访问根节点； 2.对根节点的children挨个进行深度优先遍历； const dfs = (root) => { console.log(root.val) root.children.forEach(dfs) } 广度优先 先访问离根节点最近的节点； 类似于书先看目录，再看每个章节；1.新建一个队列，把根节点入队；2.把队头出队并访问；3.把队头的children挨个排队；4.重复 2，3 直到队列为空； const bfs = (root) => { const q = [root]; while(q.lenght > 0) { const n = q.shift; console.log(n.val) n.children.forEach(item => { q.push(item); }) } } 二叉树：先/中/后序遍历 概念 树的每个节点最多只能有两个子节点；在js中一般用Object来模拟二叉树； 示例 const binaryTree = { val : 1, left : { val : 2 , left : null, right : null }, right : { val : 2 , left : null, right : null }, } 先序遍历 1.访问 根 节点； 2.对根节点的 左 子树 进行先序遍历； 3.对根节点的 右 子树 进行先序遍历； 中序遍历 1.对根节点的 左 子树 进行先序遍历； 2.访问 根 节点； 3.对根节点的 右 子树 进行先序遍历； 后序遍历 1.对根节点的 左 子树 进行先序遍历； 2.对根节点的 右 子树 进行先序遍历； 3.访问 根 节点； 二叉树：先/中/后序遍历(非递归版) 先序遍历 const preorder = (root) => { if(!root) return; const stack = [root]; while(stack.length){ const n = stack.pop(); console.log(n.val); if(n.right) stack.push(n.right); if(n.left) stack.push(n.left); } } 中序遍历 const preorder = (root) => { if(!root) return; const stack = []; const p = root; while(stack.length || p){ while(p){ stack.push(p) p.p.left; } const n = stack.pop(); console.log(n.val); p = p.right; } } 后序遍历 const preorder = (root) => { if(!root) return; const output = [] const stack = [root]; while(stack.length){ const n = stack.pop(); output.push(n) if(n.left) stack.push(n.left); if(n.right) stack.push(n.right); } while(output.length){ const n = output.pop(); console.log(n.val); } } 实例题 二叉树的最大深度 题目 力扣 104 "},"content/suanfa/tu.html":{"url":"content/suanfa/tu.html","title":"数据结构之图","keywords":"","body":"图 概念 图是 网络结构 的抽象模型，是一种由 边 连接的节点； 图可以表示任何 二元 关系，比如道路、航班... ...； JS 中没有图，但是可以用 Object 和 Array 构建图；图的表示法：邻接矩阵、邻接表、关联矩阵... ... ； 表示法 邻接矩阵 邻接表 图的常用操作 深度优先 广度优先 "},"content/suanfa/dui.html":{"url":"content/suanfa/dui.html","title":"数据结构之堆","keywords":"","body":"堆 概念 堆是一种特殊的完全二叉树；所有的节点都大于等于（最大堆）或者小于等于（最小堆）它的子节点； 最大堆 最小堆 JS中的堆 JS 中通常用数组表示堆。 一些方法 任意左侧子节点的位置是 2*index + 1；任意右节点的位置是 2*index + 2； 父节点的位置是 (index - 1)/2 的商； 堆的应用 堆能高效、快速地找出最大值和最小值，时间复杂度：O(1)； 找出第 K 个最大（小）元素； JavaScript实现：最小堆类 插入 将值插入堆的底部，即数组的尾部； 然后上移：将这个值和它的父节点进行交换，直到父节点小于等于这个插入的值； 大小为k的堆中删除堆顶的时间复杂度为O(logK)； 删除堆顶 用数组尾部元素替换堆顶（直接删除堆顶会破坏堆结构）；然后下移：将新堆顶和它的子节点进行交换，直到子节点大于等于这个新堆顶；大小为k的堆中删除堆顶的时间复杂度为O(logK)； 获取堆顶和堆的大小 获取堆顶：返回数组的头部； 获取堆的大小：返回数组的长度； class MinHeap { constructor(){ this.heap = [] } // 插入堆 insert(val){ this.heap.push(val); this.shiftUp(this.heap.length - 1); } // 删除堆顶 pop(){ this.head[0] = this.head.pop(); this.shiftDown(0) } // 获取堆顶 peek(){ return this.heap[0] } // 获取堆大小 size(){ return this.heap.length } getParentIndex(index){ // Math.floor((index -1 )/2) return (index - 1) >> 1 } swap(i1,i2){ const tmp = this.heap[i1]; this.heap[i1] = this.heap[i2]; this.heap[i2] = tmp; } getLeft(index){ return index*2 + 1 } getRight(index){ return index*2 + 2 } shiftDown(index){ const left = this.getLeft(index); const right = this.getRight(index); if(this.heap[left] this.heap[index]){ this.swap(pIndex,index) this.shiftUp(pIndex); } } } 实例题 数组中的第K个最大元素 题目 力扣 215 前K个高频元素 题目 力扣 347 合并K个排序链表 题目 力扣 23 "},"content/suanfa/suanfa-sousuo.html":{"url":"content/suanfa/suanfa-sousuo.html","title":"算法之\"搜索算法\"","keywords":"","body":"搜索排序 "},"content/suanfa/suanfa-fenzhi.html":{"url":"content/suanfa/suanfa-fenzhi.html","title":"算法设计思想之\"分而治之\"","keywords":"","body":"分而治之 "},"content/suanfa/suanfa-guihua.html":{"url":"content/suanfa/suanfa-guihua.html","title":"算法设计思想之\"动态规划\"","keywords":"","body":"动态规划 "},"content/suanfa/suanfa-tanxin.html":{"url":"content/suanfa/suanfa-tanxin.html","title":"算法设计思想之\"贪心算法\"","keywords":"","body":"贪心算法 "},"content/suanfa/suanfa-huisu.html":{"url":"content/suanfa/suanfa-huisu.html","title":"算法设计思想之\"回溯算法\"","keywords":"","body":"回溯算法 "},"content/node/readme.html":{"url":"content/node/readme.html","title":"Node相关","keywords":"","body":""}}